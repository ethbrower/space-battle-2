package com.atomicobject.rts;
import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.StringReader;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.LinkedBlockingQueue;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;
import org.w3c.dom.Node;

public class Client {
	
	BufferedReader input;
	OutputStreamWriter out;
	LinkedBlockingQueue<Map<String, Object>> updates;
	Map<Long, Unit> units;
	Tile[][] tiles;
	ArrayList<Tile> resourceTiles = new ArrayList<Tile>();

	public Client(Socket socket) {
		updates = new LinkedBlockingQueue<Map<String, Object>>();
		units = new HashMap<Long, Unit>();
		try {
			input = new BufferedReader(new InputStreamReader(socket.getInputStream()));
			out = new OutputStreamWriter(socket.getOutputStream());
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public void start() {
		System.out.println("Starting client threads ...");
		new Thread(() -> readUpdatesFromServer()).start();
		new Thread(() -> runClientLoop()).start();
	}
	
	public void readUpdatesFromServer() {
		String nextLine;
		try {
			while ((nextLine = input.readLine()) != null) {
				@SuppressWarnings("unchecked")
				Map<String, Object> update = (Map<String, Object>) JSONValue.parse(nextLine.trim());
				
				updates.add(update);
			}
		} catch (IOException e) {
			// exit thread
		}		
	}

	public void runClientLoop() {
		System.out.println("Starting client update/command processing ...");
		try {
			while (true) {
				processUpdateFromServer();
				respondWithCommands();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		closeStreams();
	}

	private void processUpdateFromServer() throws InterruptedException {
		Map<String, Object> update = updates.take();
		if (update != null) {
			System.out.println("Processing udpate: " + update);
			@SuppressWarnings("unchecked")
			Collection<JSONObject> unitUpdates = (Collection<JSONObject>) update.get("unit_updates");
			@SuppressWarnings("unchecked")
			Collection<JSONObject> tileUpdates = (Collection<JSONObject>) update.get("tile_updates");
			@SuppressWarnings("unchecked")
			JSONObject gameInfo = (JSONObject) update.get("game_info");		
			//Instantiate Tile 2D array
			if(gameInfo != null){				
				Long width = (Long)gameInfo.get("map_width");
				Long height = (Long)gameInfo.get("map_height");
				tiles = new Tile[width.intValue() * 2 + 1][height.intValue() * 2 + 1];
			}
			addUnitUpdate(unitUpdates);
			addTileUpdate(tileUpdates);

		}
	}

	private void addUnitUpdate(Collection<JSONObject> unitUpdates) {
		unitUpdates.forEach((unitUpdate) -> {
			Long id = (Long) unitUpdate.get("id");
			String type = (String) unitUpdate.get("type");
			if (!type.equals("base")) {
				units.put(id, new Unit(unitUpdate));
			}
			//System.out.println("Units: \n " + units);
		});
	}

	private void addTileUpdate(Collection<JSONObject> tileUpdates) {
		tileUpdates.forEach((tileUpdate) -> {
			Long x = (Long) tileUpdate.get("x");
			Long y = (Long) tileUpdate.get("y");
			//System.out.println(y);
			Tile tile = new Tile(tileUpdate);
			System.out.println(tile.y);
			tiles[x.intValue() + (tiles.length / 2)][y.intValue() + (tiles[0].length / 2)] = tile;
			//System.out.println("Units: \n " + units);
		});
	}

	private void respondWithCommands() throws IOException {
		if (units.size() == 0) return;
		
		JSONArray commands = buildCommandList();		
		sendCommandListToServer(commands);
	}

	@SuppressWarnings("unchecked")
	private JSONArray buildCommandList() {

		String[] directions = {"N","E","S","W"};
		String direction = directions[(int) Math.floor(Math.random() * 4)];

		Long[] unitIds = units.keySet().toArray(new Long[units.size()]);

		
		ArrayList<Unit> idleUnits = new ArrayList<Unit>();
		for(int i = 0; i < unitIds.length; i++){
			Unit unit = units.get(unitIds[i]);
			if(unit != null){
				if(unit.status.equals("idle")){
					idleUnits.add(unit);
				}
			}
		}
		
		for(int i = 0; i < tiles.length; i++){
			for(int j = 0; j < tiles[0].length; j++){
				if(tiles[i][j] != null){
					if(tiles[i][j].resources != null){
						resourceTiles.add(tiles[i][j]);
					}
				}
				
			}
		}
		
		Unit priorityUnit = idleUnits.get((int) Math.floor(Math.random() * idleUnits.size()));


		for (Unit unit : units.values()) {
			if (unit.resource != null) {
				// If the unit has resources, prioritize returning it to base
				if (priorityUnit == null || unit.getDistanceToBase() > priorityUnit.getDistanceToBase()) {
					priorityUnit = unit;
				}
			}
		}
		if (priorityUnit == null) {
			for (Unit unit_distance : units.values()) {
				if (unit_distance.resource != null) {
					// Prioritize the farthest unit 
					if (priorityUnit == null || unit_distance.getDistanceToBase() > priorityUnit.getDistanceToBase()) {
						priorityUnit = unit_distance;
					}
				}
			}
		}
		for (Unit unit_melee : units.values()) {
			if (unit_melee.hasEnemyNearby(tiles)) {
				// If there are enemies, decide whether to engage with melee or ranged attack
				if (priorityUnit == null || unit_melee.getDistanceToBase() > priorityUnit.getDistanceToBase()) {
					priorityUnit = unit_melee;
					// Initiate melee or shooting action based on unit's attack capabilities
					//initiateCombatAction(unit);
				}
			}
		}
	
			
	
		Long unitId = priorityUnit.id;
		JSONArray commands = new JSONArray();
		JSONObject command = new JSONObject();	

		if(unit.resource != null && unit.resource > 0){
			int[] coords = {unit.x.intValue(), unit.y.intValue()};
			int[] baseCoords = {0,0};

			if((Math.abs(coords[0] - baseCoords[0]) <= 1) && (Math.abs(coords[1] - baseCoords[1]) == 0) || (Math.abs(coords[0] - baseCoords[0]) == 0) && (Math.abs(coords[1] - baseCoords[1]) <= 1)){
				direction = whereToDrop(coords, baseCoords);			
				command.put("command", "DROP");
				command.put("unit", unitId);
				command.put("dir", direction);
				command.put("value", unit.resource);
				commands.add(command);
			}
			else{
				direction = findPathToPlace(tiles, coords, baseCoords);
				command.put("command", "MOVE");
				command.put("dir", direction);
				command.put("unit", unitId);
				commands.add(command);
			}
			
		}
		else{

		}
		return commands;
	}

	public String whereToDrop(int[] coords, int[] place){
		if(coords[0] - place[0] == 0){
			if(coords[1] - place[1] == 1)
				return "S";
			return "N";
		}
		else{
			if(coords[0] - place[0] == 1)
				return "W";
			return "E";
		}
	}


	public static String findPathToPlace(Tile[][] grid, int[] start, int[] place) {

		final int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        int rows = grid.length;
        int cols = grid[0].length;
        Queue<Node> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();

        // Initialize the queue with the starting position and an empty path
        queue.offer(new Node(start[0], start[1], new ArrayList<>()));
        visited.add(start[0] + "," + start[1]);

        while (!queue.isEmpty()) {
            Node current = queue.poll();
            int x = current.x;
            int y = current.y;
            List<int[]> path = current.path;

            // Check if we've reached the base
            if (x == place[0] && y == place[1]) {
                path.add(new int[]{x, y});
				int[] direction = path.get(0);
                if(direction[0] == 0){
					if(direction[1] == 1)
						return "N";
					return "S";
				}
				else{
					if(direction[1] == 1)
						return "N";
					return "S";
				}
            }

            // Explore each cardinal direction
            for (int[] direction : directions) {
                int nx = x + direction[0];
                int ny = y + direction[1];

                // Check bounds and if the cell is open and not visited
                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] != null && grid[nx][ny].blocked == false) {
                    String posKey = nx + "," + ny;
                    if (!visited.contains(posKey)) {
                        visited.add(posKey);
                        List<int[]> newPath = new ArrayList<>(path);
                        newPath.add(new int[]{x, y});
                        queue.offer(new Node(nx, ny, newPath));
                    }
                }
            }
        }

        // If no path is found
        return null;
    }

	// Helper class to store node position and path taken to reach it
    private static class Node {
        int x, y;
        List<int[]> path;

        Node(int x, int y, List<int[]> path) {
            this.x = x;
            this.y = y;
            this.path = path;
        }
    }

	@SuppressWarnings("unchecked")
	private void sendCommandListToServer(JSONArray commands) throws IOException {
		JSONObject container = new JSONObject();
		container.put("commands", commands);
		System.out.println("Sending commands: " + container.toJSONString());
		out.write(container.toJSONString());
		out.write("\n");
		out.flush();
	}

	private void closeStreams() {
		closeQuietly(input);
		closeQuietly(out);
	}

	private void closeQuietly(Closeable stream) {
		try {
			stream.close();
		} catch (IOException e1) {
			e1.printStackTrace();
		}
	}
}
